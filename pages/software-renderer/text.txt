I wanted to learn more about the graphics pipeline, so I decided to write a software renderer based on the scan-line triangle rasterisation algorithm. It has two components: a library and a demo.
The library is responsible for drawing triangles to colour and depth buffers passed to it by the application. It has the following features:
<ul><li>Scan-line triangle rasterisation</li><li>Z-buffer</li><li>Affine and perspective-correct texture mapping</li><li>Texture repeat/clamp</li><li>Bilinear texture filtering</li><li>Backface culling</li><li>Position/normal interpolation</li><li>Triange/strip/fan</li><li>Scan-line interleave</li><li>Render to texture</li><li>Depth bias</li><li>Customisable fragment shaders</li></ul>
The demo utilises most of these features and the user can cycle through different modes (e.g. affine, perspective-correct or no texture mapping). In addition, the demo features:
<ul><li>Alpha blending</li><li>Dynamic lighting</li><li>Decals</li><li>Multithreaded scan-line interleave</ul>
Alpha blending is implemented with the fragment shader system that the library provides. The shader applies alpha from the assigned texture, but alpha can also be set explicitly. Some models in the demo are entirely translucent and it is therefore possible for multiple translucent faces to occupy the same pixel. To account for this, the faces of such models are sorted and drawn back-to-front.
Dynamic lighting is also implemented in the shader. Ambient, directional and point lights are supported. Each rotating model in the demo has its own coloured light.
Decals are implemented using the depth bias feature of the library. The coloured lights on the "hologram projector" are textured surfaces placed directly on top of the projector. When no hologram is shown, these surfaces are transparent. As a hologram appears, they become more opaque, giving the illusion of illumination.
The library can be configured to skip rasterisation of some lines. The demo uses this to implement multithreaded scan-line interleave, whereby each thread is assigned different lines and writes its output to common buffers. The demo allows the user to gradually increase the number of available threads and observe how the performance changes.